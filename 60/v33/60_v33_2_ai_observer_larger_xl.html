<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>60! v33 â€” AI Observer Mode</title>
<style>
  :root{
    --bg:#0f1420; --tile-on:#3ec7c2; --tile-off:#2a3550;
    --ink:#e8eef8; --muted:#9fb3c8; --digit-ink:#e7f0ff; --gap:10px;
    --ai:#ffc857; --warn:#ff6b6b; --ok:#2ee59d; --ring:#ffd16688;
  }
  html,body{height:100%}
  body{
    margin:0; background:var(--bg); color:var(--ink);
    font-family: Inter, system-ui, Segoe UI, Roboto, Helvetica, Arial;
    display:flex; flex-direction:column; align-items:center;
    -webkit-tap-highlight-color: transparent;
  }
  h1{font-size:18px; font-weight:700; margin:10px 0 8px}
  #frame{display:flex; flex-direction:column; align-items:center}
  .hud{width:100%; box-sizing:border-box; display:flex; flex-direction:column; gap:6px; color:var(--muted); font-size:18px; padding:0 4px;}
  .row{display:flex; align-items:baseline; gap:8px; min-width:0; flex-wrap:wrap}
  .row .label{white-space:nowrap}
  #boardsHex{display:block; width:100%; overflow-x:auto; white-space:nowrap; padding-bottom:2px; border-bottom:1px dashed rgba(231,240,255,0.2);}  
  #comboLabel{font-size:14px; color:var(--muted);} 
  canvas{display:block; position:relative}
  .bar{width:100%; display:flex; justify-content:center; gap:var(--gap); flex-wrap:wrap}
  button{
    margin:12px 0 14px; padding:0; border:none; border-radius:12px;
    background:var(--tile-off); color:var(--digit-ink); font-weight:700;
    touch-action:manipulation; user-select:none;
    width:64px; height:64px; min-width:unset; display:flex; align-items:center; justify-content:center;
  }
  .btn-on{ background:var(--tile-on)!important; color:#0a1320!important; }
  @media (max-width:420px){ .hud{font-size:16px; gap:5px; padding:0 2px} h1{font-size:16px} }
  .hud, .hud .label, #boardsHex .real { color: var(--ink); font-weight:700; }
  .ai-row{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
  .pill{ display:inline-flex; align-items:center; gap:6px; padding:4px 10px; border-radius:999px; background:#1a2235; font-size:12px; }
  .pill.ai{ background:#1f2a46; border:1px solid #2b3b61; }
  .pill.badge{ background:#182033; }
  .dot{ width:8px; height:8px; border-radius:50%; background:var(--ai); display:inline-block; }
  .toast{ position:fixed; bottom:14px; left:50%; transform:translateX(-50%); background:#152038; border:1px solid #2b3b61; color:var(--ink);
          padding:10px 14px; border-radius:12px; font-size:14px; box-shadow:0 8px 20px rgba(0,0,0,0.35); opacity:0; pointer-events:none; transition:opacity .25s ease; }
  .toast.show{ opacity:1; }
</style>
</head>
<body>
<h1>60! v33 â€” AI Observer Mode</h1>
<div id="frame">
  <div class="hud" id="hud">
    <div class="row">
      <span class="label">N:</span>
      <div id="boardsHex" aria-label="6Ã—10 toggleable grid with decimal N counter"><span class="real">0</span></div>
    </div>
    <div class="row ai-row" id="aiHud" aria-live="polite">
      <span class="pill ai"><span class="dot"></span><strong>AI Observer:</strong> <span id="aiState">OFF</span></span>
      <span class="pill badge" id="aiStats">V 0% Â· H 0% Â· D 0% Â· Cl 0 Â· Ht 0 Â· H(S) 0.00</span>
      <span class="pill badge" id="aiTip">Tip: â€”</span>
    </div>
  </div>
  <canvas id="stage" aria-label="6Ã—10 toggleable grid"></canvas>
  <div class="bar">
    <button id="n1" aria-label="N1" aria-pressed="false">N1</button>
    <button id="n2" aria-label="N2" aria-pressed="false">N2</button>
    <button id="n3" aria-label="N3" aria-pressed="false">N3</button>
    <button id="n4" aria-label="N4" aria-pressed="false">N4</button>
    <button id="aiBtn" aria-label="AI Observer" aria-pressed="false">AI</button>
    <button id="exp" aria-label="Export JSON">EXP</button>
    <button id="imp" aria-label="Import JSON">IMP</button>
  </div>
</div>
<div class="toast" id="toast">New best symmetry! ðŸŽ¯</div>
<script>
(()=>{
  const COLS=6, ROWS=10;
  const DPR=Math.max(1, Math.min(window.devicePixelRatio||1, 2));
  const canvas=document.getElementById('stage');
  const ctx=canvas.getContext('2d');
  const css=v=>getComputedStyle(document.documentElement).getPropertyValue(v).trim();
  const COLORS={ BG:css('--bg'), ON:css('--tile-on'), OFF:css('--tile-off'), INK:css('--ink'), DIGIT_INK:css('--digit-ink'), RING:css('--ring') };
  const grid={ cols:COLS, rows:ROWS, size:0, pad:10, radius:12 };
  function emptyMatrix(){ return Array.from({length:grid.rows},()=>Array(grid.cols).fill(false)); }
  const defaultBoardState = ()=>({ matrix: emptyMatrix(), onCount: 0, boards: "0", bestSym: 0 });
  let boardsState = Array.from({length:16}, defaultBoardState);
  let activeButtons = [false,false,false,false];
  let viewIndex = 0;
  let observerOn=false;
  let heat = Array.from({length:grid.rows},()=>Array(grid.cols).fill(0));
  let suggestCell = null; // {r,c}

  const elBoardsHex=document.getElementById('boardsHex');
  const hud=document.getElementById('hud');
  const frame=document.getElementById('frame');
  const aiHud=document.getElementById('aiHud');
  const aiState=document.getElementById('aiState');
  const aiStats=document.getElementById('aiStats');
  const aiTip=document.getElementById('aiTip');
  const toast=document.getElementById('toast');

  const btns=[
    document.getElementById('n1'),
    document.getElementById('n2'),
    document.getElementById('n3'),
    document.getElementById('n4'),
  ];
  const btnAI=document.getElementById('aiBtn');
  const btnEXP=document.getElementById('exp');
  const btnIMP=document.getElementById('imp');

  const STORAGE_KEY=`v33_en_binmask_${COLS}x${ROWS}_combo16`;
  const HEAT_KEY=`v33_observer_heat_${COLS}x${ROWS}`;

  function maskFromButtons(){
    return (activeButtons[0]?1:0) | (activeButtons[1]?2:0) | (activeButtons[2]?4:0) | (activeButtons[3]?8:0);
  }
  function bin4(m){ return m.toString(2).padStart(4,'0'); }

  function fitCanvas(){
    const outer=18, h1=document.querySelector('h1'), bar=document.querySelector('.bar');
    const h1H=h1?h1.getBoundingClientRect().height:0;
    const hudH=hud?hud.getBoundingClientRect().height:0;
    const barH=bar?bar.getBoundingClientRect().height:0;
    const safetyY=18;
    const maxW=Math.max(320, window.innerWidth-outer*2);
    const maxH=Math.max(260, window.innerHeight-(h1H+hudH+barH+safetyY+outer*2));
    grid.pad=Math.round(Math.max(8, Math.min(16, Math.min(maxW,maxH)*0.025)));
    const sizeFromW=Math.floor((maxW-(grid.pad*(grid.cols+1)))/grid.cols);
    const sizeFromH=Math.floor((maxH-(grid.pad*(grid.rows+1)))/grid.rows);
    const MAX_TILE=Math.min(128, Math.floor(window.innerWidth/4.8));
    grid.size=Math.min(MAX_TILE, Math.max(48, Math.min(sizeFromW,sizeFromH)));
    const cssW=grid.cols*(grid.size+grid.pad)+grid.pad;
    const cssH=grid.rows*(grid.size+grid.pad)+grid.pad;
    frame.style.width=cssW+'px';
    canvas.style.width=cssW+'px';
    canvas.style.height=cssH+'px';
    canvas.width=Math.round(cssW*DPR);
    canvas.height=Math.round(cssH*DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
    document.documentElement.style.setProperty('--gap', grid.pad + 'px');
    const tileFont = Math.max(16, Math.floor(grid.size*0.42)) + 'px';
    [...btns, btnAI, btnEXP, btnIMP].forEach((btn)=>{
      btn.style.width = grid.size + 'px';
      btn.style.height = grid.size + 'px';
      btn.style.borderRadius = grid.radius + 'px';
      btn.style.fontSize = tileFont;
    });
    draw();
  }

  function saveState(){ 
    try{ 
      localStorage.setItem(STORAGE_KEY, JSON.stringify({boardsState, activeButtons, viewIndex, observerOn}));
      localStorage.setItem(HEAT_KEY, JSON.stringify(heat)); 
    }catch(e){} 
  }
  function loadState(){
    try{
      const s=localStorage.getItem(STORAGE_KEY);
      if(s){
        const st=JSON.parse(s);
        if(st && Array.isArray(st.boardsState) && st.boardsState.length===16){
          boardsState = st.boardsState.map((b)=>({ ...defaultBoardState(), ...b }));
          if(Array.isArray(st.activeButtons) && st.activeButtons.length===4){ activeButtons = st.activeButtons.map(Boolean); }
          if(typeof st.viewIndex==='number') viewIndex = Math.max(0, Math.min(15, st.viewIndex));
          if(typeof st.observerOn==='boolean') observerOn = st.observerOn;
        }
      }
      const h=localStorage.getItem(HEAT_KEY);
      if(h){ const hh=JSON.parse(h); if(Array.isArray(hh) && hh.length===grid.rows) heat=hh; }
    }catch(e){ localStorage.removeItem(STORAGE_KEY); localStorage.removeItem(HEAT_KEY); }
  }

  function rr(x,y,w,h,r){ const a=Math.min(r,w/2,h/2);
    ctx.beginPath(); ctx.moveTo(x+a,y); ctx.arcTo(x+w,y,x+w,y+h,a);
    ctx.arcTo(x+w,y+h,x,y+h,a); ctx.arcTo(x,y+h,x,y,a); ctx.arcTo(x,y,x+w,y,a); ctx.closePath();
  }
  function drawHex(cx,cy,txt,isOn){
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.font='700 '+Math.max(16,Math.floor(grid.size*0.42))+'px Inter, system-ui, Segoe UI, Roboto, Helvetica, Arial';
    ctx.fillStyle=isOn?'#0a1320':COLORS.DIGIT_INK;
    ctx.fillText(txt,cx,cy);
  }

  function renderBoardsDisplay(v){
    elBoardsHex.innerHTML='<span class="real">'+v+'</span>';
    requestAnimationFrame(()=>{ elBoardsHex.scrollLeft=elBoardsHex.scrollWidth; });
  }

  function entropy(p){ if(p<=0||p>=1) return 0; return -(p*Math.log2(p) + (1-p)*Math.log2(1-p)); }

  function symmetryScores(m){
    const R=grid.rows, C=grid.cols;
    let vhits=0, vtotal=0, hhits=0, htotal=0, d1hits=0, d1total=0, d2hits=0, d2total=0;
    for(let r=0;r<R;r++){
      for(let c=0;c<C;c++){
        // vertical mirror
        const cv=C-1-c; vtotal++; if(m[r][c]===m[r][cv]) vhits++;
        // horizontal mirror
        const rrIdx=R-1-r; htotal++; if(m[r][c]===m[rrIdx][c]) hhits++;
        // diag TL-BR
        if(r<C && c<R){ d1total++; if(m[r][c]===m[c]?.[r]) d1hits++; }
        // diag TR-BL
        const rc=(C-1-c); if(r<C && rc<R){ d2total++; if(m[r][c]===m[rc]?.[r]) d2hits++; }
      }
    }
    const V=vhits/vtotal, H=hhits/htotal, D1=d1total?d1hits/d1total:0, D2=d2total?d2hits/d2total:0;
    return {V, H, D1, D2, avg:(V+H+D1+D2)/4};
  }

  function clustersCount(m){
    const R=grid.rows, C=grid.cols; const seen=Array.from({length:R},()=>Array(C).fill(false));
    let clusters=0; const q=[]; const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    for(let r=0;r<R;r++) for(let c=0;c<C;c++) if(m[r][c] && !seen[r][c]){ clusters++; seen[r][c]=true; q.push([r,c]);
      while(q.length){ const [y,x]=q.shift(); for(const [dy,dx] of dirs){ const ny=y+dy, nx=x+dx; if(ny>=0&&ny<R&&nx>=0&&nx<C && m[ny][nx] && !seen[ny][nx]){ seen[ny][nx]=true; q.push([ny,nx]); } } }
    }
    return clusters;
  }

  function matrixCopy(m){ return m.map(row=>row.slice()); }

  function suggestBestCell(m){
    // Try flipping each cell, choose the one maximizing avg symmetry; tie-breaker: lower entropy
    const base = symmetryScores(m); const baseAvg=base.avg;
    let best=null; let bestAvg=baseAvg; let bestEnt=Infinity;
    const R=grid.rows, C=grid.cols;
    let on=0; for(let r=0;r<R;r++) for(let c=0;c<C;c++) if(m[r][c]) on++;
    for(let r=0;r<R;r++){
      for(let c=0;c<C;c++){
        const mm=matrixCopy(m); mm[r][c]=!mm[r][c];
        const s=symmetryScores(mm).avg;
        const p=((on + (mm[r][c]?1:-1)))/(R*C); const e=entropy(p);
        if(s>bestAvg || (Math.abs(s-bestAvg)<1e-9 && e<bestEnt)){
          bestAvg=s; bestEnt=e; best={r,c};
        }
      }
    }
    return best; // can be null if unchanged
  }

  function updateAIHud(){
    const b=boardsState[viewIndex];
    const m=b.matrix; const R=grid.rows, C=grid.cols;
    let on=0; for(let r=0;r<R;r++) for(let c=0;c<C;c++) if(m[r][c]) on++;
    const dens = on/(R*C);
    const sym = symmetryScores(m);
    const cl = clustersCount(m);
    const ent = entropy(dens);
    aiStats.textContent = `V ${(sym.V*100|0)}% Â· H ${(sym.H*100|0)}% Â· D ${(((sym.D1+sym.D2)/2)*100|0)}% Â· Cl ${cl} Â· Ht ${totalHeat()} Â· H(S) ${ent.toFixed(2)}`;
    if(observerOn){ suggestCell = suggestBestCell(m); aiTip.textContent = suggestCell ? `Tip: toggle ${cellLabel(suggestCell.r, suggestCell.c)}` : 'Tip: â€”'; }
    else { suggestCell=null; aiTip.textContent='Tip: â€”'; }

    // Toast for new best symmetry
    const currentAvg = sym.avg;
    if(currentAvg > (b.bestSym||0)+1e-9){ b.bestSym = currentAvg; showToast('New best symmetry! ðŸŽ¯'); }
  }

  function showToast(msg){ toast.textContent=msg; toast.classList.add('show'); setTimeout(()=>toast.classList.remove('show'), 1200); }

  function cellLabel(r,c){ // hex index like original; also A1-style fallback
    const idx=r*grid.cols+c; const hex=idx.toString(16).toUpperCase().padStart(2,'0'); return hex; }

  function totalHeat(){ let s=0; for(let r=0;r<grid.rows;r++) for(let c=0;c<grid.cols;c++) s+=heat[r][c]; return s; }

  function draw(){
    const b = boardsState[viewIndex];
    ctx.fillStyle=COLORS.BG; ctx.fillRect(0,0,canvas.width/DPR,canvas.height/DPR);
    for(let r=0;r<grid.rows;r++){
      for(let c=0;c<grid.cols;c++){
        const idx=r*grid.cols+c, hex=idx.toString(16).toUpperCase().padStart(2,'0');
        const x=c*(grid.size+grid.pad)+grid.pad, y=r*(grid.size+grid.pad)+grid.pad;
        rr(x,y,grid.size,grid.size,grid.radius);
        const on=b.matrix[r][c]; ctx.fillStyle=on?COLORS.ON:COLORS.OFF; ctx.fill(); 
        drawHex(x+grid.size/2, y+grid.size/2, hex, on);
      }
    }
    // Heatmap overlay (observer)
    if(observerOn){
      let maxH=1; for(let r=0;r<grid.rows;r++) for(let c=0;c<grid.cols;c++) maxH=Math.max(maxH, heat[r][c]);
      for(let r=0;r<grid.rows;r++){
        for(let c=0;c<grid.cols;c++){
          if(heat[r][c]>0){
            const x=c*(grid.size+grid.pad)+grid.pad, y=r*(grid.size+grid.pad)+grid.pad;
            const alpha = Math.min(0.55, (Math.log(1+heat[r][c])/Math.log(1+maxH)) * 0.55);
            ctx.fillStyle = `rgba(255, 209, 102, ${alpha})`; // heat amber
            rr(x,y,grid.size,grid.size,grid.radius); ctx.fill();
          }
        }
      }
      // Suggest ring
      if(suggestCell){
        const {r,c}=suggestCell; const x=c*(grid.size+grid.pad)+grid.pad, y=r*(grid.size+grid.pad)+grid.pad;
        ctx.lineWidth=3; ctx.setLineDash([6,6]); ctx.strokeStyle=COLORS.RING; rr(x+2,y+2,grid.size-4,grid.size-4,grid.radius-4); ctx.stroke(); ctx.setLineDash([]);
      }
    }
  }

  function bigAdd(a,b){
    let res='',carry=0,i=a.length-1,j=b.length-1;
    while(i>=0||j>=0||carry){
      const da=i>=0?(a.charCodeAt(i)-48):0;
      const db=j>=0?(b.charCodeAt(j)-48):0;
      const s=da+db+carry; res=(s%10)+res; carry=(s/10)|0; i--; j--;
    }
    let k=0; while(k<res.length-1 && res[k]==='0') k++; 
    return res.slice(k);
  }

  function syncHUD(){ 
    const b=boardsState[viewIndex];
    renderBoardsDisplay(b.boards); 
    aiState.textContent = observerOn ? `ON (N=${bin4(viewIndex)})` : 'OFF';
    updateAIHud();
    saveState(); 
  }

  function toggleCell(r,c){
    const b = boardsState[viewIndex];
    b.matrix[r][c] = !b.matrix[r][c];
    b.onCount += b.matrix[r][c] ? 1 : -1;
    b.boards = bigAdd(b.boards, '1');
    heat[r][c] += 1; // heat update for observer
    syncHUD();
    draw();
  }

  function pointerXY(e){ const rect=canvas.getBoundingClientRect(); const x=(e.touches?e.touches[0].clientX:e.clientX)-rect.left; const y=(e.touches?e.touches[0].clientY:e.clientY)-rect.top; return {x,y}; }
  function toggleAt(x,y){
    for(let r=0;r<grid.rows;r++){
      for(let c=0;c<grid.cols;c++){
        const cx=c*(grid.size+grid.pad)+grid.pad, cy=r*(grid.size+grid.pad)+grid.pad;
        if(x>=cx && x<=cx+grid.size && y>=cy && y<=cy+grid.size){ toggleCell(r,c); return; }
      }
    }
  }
  canvas.addEventListener('click', e=>{ const p=pointerXY(e); toggleAt(p.x,p.y); });
  let touchMoved=false;
  canvas.addEventListener('touchstart', ()=>{ touchMoved=false; }, {passive:true});
  canvas.addEventListener('touchmove',  ()=>{ touchMoved=true;  }, {passive:true});
  canvas.addEventListener('touchend',   e=>{ if(!touchMoved){ const p=pointerXY(e); toggleAt(p.x,p.y); } }, {passive:true});

  function renderButtons(){ 
    btns.forEach((btn, i)=>{
      const on = !!activeButtons[i];
      btn.classList.toggle('btn-on', on); 
      btn.setAttribute('aria-pressed', String(on)); 
      btn.style.background = on ? COLORS.ON : COLORS.OFF;
      btn.style.color = on ? '#0a1320' : COLORS.DIGIT_INK;
    });
    btnAI.classList.toggle('btn-on', observerOn);
    btnAI.setAttribute('aria-pressed', String(observerOn));
  }
  function pressButton(index){
    activeButtons[index] = !activeButtons[index];
    viewIndex = maskFromButtons();
    renderButtons();
    syncHUD();
    draw();
  }
  btns.forEach((btn, i)=> btn.addEventListener('click', ()=>pressButton(i)));

  btnAI.addEventListener('click', ()=>{ observerOn = !observerOn; renderButtons(); syncHUD(); draw(); });

  // Export / Import
  btnEXP.addEventListener('click', ()=>{
    const payload = { boardsState, activeButtons, viewIndex, heat, version:'v33-ai', cols:grid.cols, rows:grid.rows };
    const data = 'data:application/json;charset=utf-8,'+encodeURIComponent(JSON.stringify(payload));
    const a=document.createElement('a'); a.href=data; a.download=`60_v33_export_${Date.now()}.json`; a.click();
  });
  btnIMP.addEventListener('click', async ()=>{
    const inp=document.createElement('input'); inp.type='file'; inp.accept='.json,application/json';
    inp.onchange=async()=>{
      const f=inp.files?.[0]; if(!f) return; const txt=await f.text();
      try{
        const obj=JSON.parse(txt);
        if(obj && obj.boardsState && obj.cols===grid.cols && obj.rows===grid.rows){
          boardsState = obj.boardsState.map((b)=>({ ...defaultBoardState(), ...b }));
          activeButtons = Array.isArray(obj.activeButtons) ? obj.activeButtons.map(Boolean) : activeButtons;
          viewIndex = typeof obj.viewIndex==='number' ? obj.viewIndex : viewIndex;
          heat = Array.isArray(obj.heat) && obj.heat.length===grid.rows ? obj.heat : heat;
          showToast('Import ok âœ…');
          renderButtons(); syncHUD(); draw();
        } else { showToast('Import mismatch âš ï¸'); }
      }catch(err){ showToast('Import failed âŒ'); }
    };
    inp.click();
  });

  function refitAll(){ fitCanvas(); renderButtons(); }
  window.addEventListener('resize', refitAll);
  window.addEventListener('orientationchange', refitAll);
  const ro=new ResizeObserver(()=>refitAll()); ro.observe(hud); ro.observe(elBoardsHex);
  if(document.fonts && document.fonts.ready){ document.fonts.ready.then(()=>refitAll()); }

  // Init
  loadState();
  // Ensure 16 boards
  if(!boardsState || boardsState.length!==16){ boardsState = Array.from({length:16}, defaultBoardState); }
  viewIndex = maskFromButtons();
  renderButtons();
  syncHUD();
  draw();
  refitAll();
  setTimeout(refitAll,0); setTimeout(refitAll,50); setTimeout(refitAll,150);
})();
</script>
</body>
</html>
